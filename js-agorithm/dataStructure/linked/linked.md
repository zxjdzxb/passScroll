# 链表

#### 数组

- 存储多个元素，数组（或列表）可能是最常用的数据结构。

- 几乎每一种编程语言都有默认实现数组结构，提供了一个便利的 `[]` 语法来访问数组元素。

- 数组缺点：

  数组的创建需要申请一段连续的内存空间(一整块内存)，并且大小是固定的，当前数组不能满足容量需求时，需要扩容。 (一般情况下是申请一个更大的数组，比如 2 倍，然后将原数组中的元素复制过去)

  在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。

#### 链表

- 存储多个元素，另外一个选择就是使用链表。

- 不同于数组，链表中的元素在内存中不必是连续的空间。

- 链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用(有些语言称为指针)组成。

- 链表优点：

  内存空间不必是连续的，可以充分利用计算机的内存，实现灵活的内存动态管理。

  链表不必在创建时就确定大小，并且大小可以无限延伸下去。

  链表在插入和删除数据时，时间复杂度可以达到 O(1)，相对数组效率高很多。

- 链表缺点：

  访问任何一个位置的元素时，需要从头开始访问。(无法跳过第一个元素访问任何一个元素)

  无法通过下标值直接访问元素，需要从头开始一个个访问，直到找到对应的元素。

  虽然可以轻松地到达下一个节点，但是回到前一个节点是很难的。

## 单项列表

单向链表类似于火车，有一个火车头，火车头会连接一个节点，节点上有乘客，并且这个节点会连接下一个节点，以此类推。

- 链表的火车结构

  [![链表的火车结构](https://camo.githubusercontent.com/94a87d696b54c3c2e8dd2c7461cf4de0c582eaae8613c5d8399511517e1332c4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e323778746e336335327a77672e706e67)](https://camo.githubusercontent.com/94a87d696b54c3c2e8dd2c7461cf4de0c582eaae8613c5d8399511517e1332c4/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e323778746e336335327a77672e706e67)

- 链表的数据结构

  head 属性指向链表的第一个节点。
  链表中的最后一个节点指向 `null`。 当链表中一个节点也没有的时候，head 直接指向 `null`。

  [![链表的数据结构](https://camo.githubusercontent.com/cb80edbb70576fc4ec368cc82817af2fcedbee2d7d2c95fc0faabca1791cdc09/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e33376a3162793436613132302e706e67)](https://camo.githubusercontent.com/cb80edbb70576fc4ec368cc82817af2fcedbee2d7d2c95fc0faabca1791cdc09/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e33376a3162793436613132302e706e67)

- 给火车加上数据后的结构

  [![给火车加上数据后的结构](https://camo.githubusercontent.com/056ab81adb200c31e9e6a317baa2d049875834d13804b7cb841a42e829e82633/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e363634646a696965327438302e706e67)](https://camo.githubusercontent.com/056ab81adb200c31e9e6a317baa2d049875834d13804b7cb841a42e829e82633/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e363634646a696965327438302e706e67)

### 链表中的常见操作

- `append(element)` 向链表尾部添加一个新的项。
- `insert(position, element)` 向链表的特定位置插入一个新的项。
- `get(position)` 获取对应位置的元素。
- `indexOf(element)` 返回元素在链表中的索引。如果链表中没有该元素就返回-1。
- `update(position, element)` 修改某个位置的元素。
- `removeAt(position)` 从链表的特定位置移除一项。
- `remove(element)` 从链表中移除一项。
- `isEmpty()` 如果链表中不包含任何元素，返回 trun，如果链表长度大于 0 则返回 false。
- `size()` 返回链表包含的元素个数，与数组的 length 属性类似。
- `toString()` 由于链表项使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString 方法，让其只输出元素的值。

#### 过程图解

- 首先让 `currentNode` 指向第一个节点。

  [![image](https://camo.githubusercontent.com/3e0b65c86f921507484e6b90fa7fac4180f2baabc376c9230500c7bfbd5d95ca/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e3569736b726466346e7534302e706e67)](https://camo.githubusercontent.com/3e0b65c86f921507484e6b90fa7fac4180f2baabc376c9230500c7bfbd5d95ca/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e3569736b726466346e7534302e706e67)

- 通过 `while` 循环使 `currentNode` 指向最后一个节点，最后通过 `currentNode.next = newNode`，让最后一个节点指向新节点 `newNode`。

  [![image](https://camo.githubusercontent.com/c2a46eef80970048eae3327cb1243d44d25737c10ad32574ca81945280837358/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e346d77336278356738306d302e706e67)](https://camo.githubusercontent.com/c2a46eef80970048eae3327cb1243d44d25737c10ad32574ca81945280837358/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e346d77336278356738306d302e706e67)

  
  
  ## 双向链表
  
  - 既可以从头遍历到尾，也可以从尾遍历到头。
  
  - 链表相连的过程是双向的。实现原理是一个节点既有向前连接的引用，也有一个向后连接的引用。
  
  - 双向链表可以有效的解决单向链表存在的问题。
  
  - 双向链表缺点：
  
    - 每次在插入或删除某个节点时，都需要处理四个引用，而不是两个，实现起来会困难些。
    - 相对于单向链表，所占内存空间更大一些。
    - 但是，相对于双向链表的便利性而言，这些缺点微不足道。
  
    [![image](https://camo.githubusercontent.com/a6e84b4bd6c3bac0eab8a993cfb73d93c3ea28b131e12303e08b9ce9cdf2b120/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e3378793736396839307632302e706e67)](https://camo.githubusercontent.com/a6e84b4bd6c3bac0eab8a993cfb73d93c3ea28b131e12303e08b9ce9cdf2b120/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f58506f65742f696d6167652d686f7374696e67406d61737465722f4a6176615363726970742d2545362539352542302545362538442541452545372542422539332545362539452538342545342542382538452545372541452539372545362542332539352f696d6167652e3378793736396839307632302e706e67)
  
    - 双向链表不仅有 head 指针指向第一个节点，而且有 tail 指针指向最后一个节点。
    - 每一个节点由三部分组成：item 储存数据、prev 指向前一个节点、next 指向后一个节点。
    - 双向链表的第一个节点的 prev 指向 null。
    - 双向链表的最后一个节点的 next 指向 null。
  
    
  
  