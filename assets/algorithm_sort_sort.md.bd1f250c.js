import{_ as a,o as t,c as l,Q as o}from"./chunks/framework.2576a40d.js";const u=JSON.parse('{"title":"排序算法总结","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/sort/sort.md","filePath":"algorithm/sort/sort.md","lastUpdated":1704447128000}'),e={name:"algorithm/sort/sort.md"},i=o('<h1 id="排序算法总结" tabindex="-1">排序算法总结 <a class="header-anchor" href="#排序算法总结" aria-label="Permalink to &quot;排序算法总结&quot;">​</a></h1><h2 id="快速排序相对于其他排序效率更高的原因" tabindex="-1">快速排序相对于其他排序效率更高的原因 <a class="header-anchor" href="#快速排序相对于其他排序效率更高的原因" aria-label="Permalink to &quot;快速排序相对于其他排序效率更高的原因&quot;">​</a></h2><p>上面一共提到了8种排序的方法，在实际使用中，应用最广泛的是快速排序。快速排序相对于其他排序算法的优势在于在相同 数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p><p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本趋向于 O(n²)，因此只从时间复杂度上来看 的话，显然归并排序、堆排序和快速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快速排序在最 坏情况下时间的复杂度还会变为 O(n²)，那么为什么它的效率反而更高呢？</p><p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并排序在这种情况下会需要过多的额外内存，因 此归并排序首先就被排除掉了。</p><p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率不高的原因有两个方面。</p><p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比较都会确定该元素在数组中的位置，也就是在 枢纽值的左边或者右边，快速排序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整堆的时候，我 们在迭代时，已经知道上层的节点值一定比下层的节点值大，因此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互 换时，互换后的元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进行再一次的比较，这样的比较 是没有意义的，以此在堆排序中会产生大量的没有意义的比较操作。</p><p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排序的效率不如快速排序的主要原因。在计算机 中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原 理，局部性原理简单来说就是，当前被访问过的数据，很有可能在一段时间内被再次访问，这被称为时间局部性。还有就是当 前访问的数据，那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计算机缓存利用了局部性的原理 来对数据进行缓存，来尽可能少的减少磁盘的 I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于 空间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔很远的元素，这对于利用空间局部性来进行 数据缓存的计算机来说，它的很多缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显 提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来 说，它的排序每一次都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原理，因此它的执行效率更 高。简单来说就是在堆排序中获取一个元素的值所花费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可 以看出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决定算法执行效率的还有内存读取这样的其 他的因素。</p><h2 id="系统自带排序实现" tabindex="-1">系统自带排序实现 <a class="header-anchor" href="#系统自带排序实现" aria-label="Permalink to &quot;系统自带排序实现&quot;">​</a></h2><p>每个语言的排序内部实现都是不同的。</p><p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p><h2 id="稳定性" tabindex="-1">稳定性 <a class="header-anchor" href="#稳定性" aria-label="Permalink to &quot;稳定性&quot;">​</a></h2><p>稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面， 而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。</p><p>稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个列表进行渲染， 当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。</p><h2 id="排序面试题目总结" tabindex="-1">排序面试题目总结 <a class="header-anchor" href="#排序面试题目总结" aria-label="Permalink to &quot;排序面试题目总结&quot;">​</a></h2><ol><li><p>快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。</p></li><li><p>初始数据集的排列顺序对算法的性能无影响的有堆排序，直接选择排序，归并排序，基数排序。</p></li><li><p>合并 m 个长度为 n 的已排序数组的时间复杂度为 O(nmlogm)。</p></li><li><p>外部排序常用的算法是归并排序。</p></li><li><p>数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。</p></li><li><p>如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。</p></li><li><p>插入排序和优化后的冒泡在最优情况（有序）都只用比较 n-1 次。</p></li><li><p>对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。</p></li><li><p>下标从1开始，在含有 n 个关键字的小根堆（堆顶元素最小）中，关键字最大的记录有可能存储在 [n/2]+2 位置上。 因为小根堆中最大的数一定是放在叶子节点上，堆本身是个完全二叉树，完全二叉树的叶子节点的位置大于 [n/2]。</p></li><li><p>拓扑排序的算法，每次都选择入度为0的结点从图中删去，并从图中删除该顶点和所有以它为起点的有向边。</p></li><li><p>任何一个基于&quot;比较&quot;的内部排序的算法，若对 n 个元素进行排序，则在最坏情况下所需的比较次数 k 满足 2^k &gt; n!， 时间下界为 O(nlogn)</p></li></ol><p>12.m 个元素 k 路归并的归并趟数 s=logk(m)，代入数据：logk(100)≦3</p><ol start="13"><li>对 n 个记录的线性表进行快速排序为减少算法的递归深度，每次分区后，先处理较短的部分。</li></ol><p>在用邻接表表示图时，拓扑排序算法时间复杂度为 O(n+e)</p>',19),p=[i];function n(r,s,h,c,d,_){return t(),l("div",null,p)}const O=a(e,[["render",n]]);export{u as __pageData,O as default};
