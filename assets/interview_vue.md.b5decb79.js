import{_ as a,o as e,c as s,Q as l}from"./chunks/framework.2576a40d.js";const m=JSON.parse('{"title":"Vue","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue.md","filePath":"interview/vue.md","lastUpdated":1702462037000}'),o={name:"interview/vue.md"},t=l(`<h1 id="vue" tabindex="-1">Vue <a class="header-anchor" href="#vue" aria-label="Permalink to &quot;Vue&quot;">​</a></h1><h2 id="谈谈你对-vue-的理解-为什么使用-vue-进行开发" tabindex="-1">谈谈你对 Vue 的理解？为什么使用 Vue 进行开发？ <a class="header-anchor" href="#谈谈你对-vue-的理解-为什么使用-vue-进行开发" aria-label="Permalink to &quot;谈谈你对 Vue 的理解？为什么使用 Vue 进行开发？&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><ol><li><p>Vue 对于前端初学者比较友好。一个 Vue 文件的结构和原生 HTML 保持了高度相似，分为静态页面，用于放置 html 标签，和 script，用于处理用户操作和业务逻辑，最后是 style 样式，用于书写 CSS 代码，这种写法可以让初学者感到习惯。</p></li><li><p>Vue 提供了许多 JS 定制化的操作，比如 v-bind 和事件监听的 @ 符号，开发者可以直接使用，从而减少一些重复代码的书写。</p></li><li><p>Vue 提供一套高效的响应式的系统用于更新 DOM，可以让开发者专注于处理业务而非技术实现。</p></li><li><p>Vue 鼓励组件化开发，开发者可以将部分界面提取为组件，尤其是复用性较高的界面，使代码更加模块化、可维护性更高。</p></li><li><p>Vue 在国内拥有庞大且活跃的社区，开发者可以获得丰富的文档、教程、插件和支持。</p></li></ol></details><h2 id="mvvm" tabindex="-1">MVVM <a class="header-anchor" href="#mvvm" aria-label="Permalink to &quot;MVVM&quot;">​</a></h2><p>MVVM，即 Model–View–ViewModel，是一种软件架构模式。</p><details class="details custom-block"><summary>答案</summary><ul><li><p>Model 即模型，是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p></li><li><p>View 即视图，是用户在屏幕上看到的结构、布局和外观（UI）。</p></li><li><p>ViewModel 即视图模型，是暴露公共属性和命令的视图的抽象。用于把 Model 和 View 关联起来。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model 。</p></li></ul></details><h2 id="vue-响应式系统的原理" tabindex="-1">Vue 响应式系统的原理 <a class="header-anchor" href="#vue-响应式系统的原理" aria-label="Permalink to &quot;Vue 响应式系统的原理&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 实现响应式主要是采用数据劫持结合发布者-订阅者模式的方式。 当谈论 Vue 2 和 Vue 3 的响应式系统时，有一些关键的区别值得注意。Vue 3 在性能和可维护性上做出了一些改进，其中响应式系统也有一些重要的变化。</p><h3 id="vue-2-的响应式系统" tabindex="-1">Vue 2 的响应式系统： <a class="header-anchor" href="#vue-2-的响应式系统" aria-label="Permalink to &quot;Vue 2 的响应式系统：&quot;">​</a></h3><ol><li><p><strong>Object.defineProperty()：</strong> Vue 2 使用了 <code>Object.defineProperty()</code> 来实现数据的响应式。它会在数据属性被访问时添加 getter，当属性被修改时触发 setter，从而通知相关的依赖进行更新。</p></li><li><p><strong>递归遍历与依赖追踪：</strong> 在 Vue 2 中，当 Vue 实例化时，会递归地遍历 data 对象的属性，并将其转换为 getter/setter，同时建立依赖追踪，记录每个属性对应的依赖。</p></li><li><p><strong>Watcher：</strong> Vue 2 中使用 Watcher 实例来收集依赖，并在数据变化时触发更新，通知相关的 Watcher 更新视图。</p></li></ol><h3 id="vue-3-的响应式系统" tabindex="-1">Vue 3 的响应式系统： <a class="header-anchor" href="#vue-3-的响应式系统" aria-label="Permalink to &quot;Vue 3 的响应式系统：&quot;">​</a></h3><ol><li><p><strong>Proxy：</strong> Vue 3 弃用了 Object.defineProperty()，改用 JavaScript 的 Proxy API。Proxy 可以劫持对象的各种操作，提供更灵活和高效的拦截器。Vue 3 使用 Proxy 来实现响应式，比 Vue 2 更加直接且性能更好。</p></li><li><p><strong>递归遍历的优化：</strong> Vue 3 对递归遍历进行了优化，降低了初始化时的性能消耗，并减少了不必要的依赖追踪。</p></li><li><p><strong>WeakMap 缓存：</strong> Vue 3 使用 WeakMap 缓存了属性和对应的依赖关系，提高了依赖追踪的效率。</p></li><li><p><strong>Composables 和函数式 API：</strong> Vue 3 引入了 Composables 和函数式 API，使得响应式系统更灵活、模块化，并且更易于组合和测试。</p></li><li><p><strong>优化的更新策略：</strong> Vue 3 在虚拟 DOM 和渲染方面进行了多项优化，提高了整体的性能表现。</p></li></ol><p>在面试中，着重强调 Vue 3 使用了 Proxy 来实现响应式系统，相比于 Vue 2 使用的 Object.defineProperty()，这种方式更加直接且性能更好。同时提到了 Vue 3 对于初始化性能的优化、引入 Composables 和函数式 API，以及优化的更新策略等方面的改进。</p></details><h2 id="vue-是如何实现数据双向绑定的-v-model-的原理" tabindex="-1">Vue 是如何实现数据双向绑定的？v-model 的原理？ <a class="header-anchor" href="#vue-是如何实现数据双向绑定的-v-model-的原理" aria-label="Permalink to &quot;Vue 是如何实现数据双向绑定的？v-model 的原理？&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 组件可以通过使用 v-model 指令以实现双向绑定。 v-model 是 vue 的一个语法糖，它用于监听数据的改变并将数据更新。以 input 元素为例：</p><div class="language-HTML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTML</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">el-input</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-model</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;foo&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">el-input</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-model</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;foo&quot;</span><span style="color:#24292E;"> /&gt;</span></span></code></pre></div><p>其实就等价于</p><div class="language-HTML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTML</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">input</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">:value</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;searchText&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">@input</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;searchText = $event.target.value&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">input</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">:value</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;searchText&quot;</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">@input</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;searchText = $event.target.value&quot;</span><span style="color:#24292E;"> /&gt;</span></span></code></pre></div></details><h2 id="computed-和-watch-的区别" tabindex="-1">Computed 和 Watch 的区别 <a class="header-anchor" href="#computed-和-watch-的区别" aria-label="Permalink to &quot;Computed 和 Watch 的区别&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p><code>Computed</code> 和 <code>Watch</code> 是 Vue 中用于观察数据变化并执行相应操作的两种主要方式，它们有着不同的应用场景和工作方式。</p><h3 id="computed-计算属性" tabindex="-1">Computed（计算属性）： <a class="header-anchor" href="#computed-计算属性" aria-label="Permalink to &quot;Computed（计算属性）：&quot;">​</a></h3><ul><li><strong>用途：</strong> 计算属性用于根据已有的数据计算出一个新的属性，并将这个属性缓存起来，只有依赖的响应式数据发生变化时才会重新计算。</li><li><strong>声明方式：</strong> 使用 <code>computed</code> 对象声明计算属性。</li><li><strong>特点：</strong><ul><li>缓存：计算属性会缓存计算结果，在依赖数据不变的情况下不会重新计算。</li><li>响应性：计算属性依赖于响应式数据，当依赖数据变化时，计算属性会重新计算。</li><li>计算开销：适合进行复杂的计算操作，避免在模板中写复杂的逻辑。</li></ul></li></ul><h3 id="watch-侦听器" tabindex="-1">Watch（侦听器）： <a class="header-anchor" href="#watch-侦听器" aria-label="Permalink to &quot;Watch（侦听器）：&quot;">​</a></h3><ul><li><strong>用途：</strong> Watch 用于观察和响应特定数据的变化，可以执行自定义的操作，例如异步操作或复杂逻辑处理。</li><li><strong>声明方式：</strong> 使用 <code>watch</code> 选项或者 <code>$watch</code> 方法来声明一个观察者。</li><li><strong>特点：</strong><ul><li>灵活性：能够监听任何数据的变化，包括对象、数组的变化，以及深度监听。</li><li>异步操作：可以在数据变化时执行异步操作或复杂的业务逻辑。</li></ul></li></ul><h3 id="区别总结" tabindex="-1">区别总结： <a class="header-anchor" href="#区别总结" aria-label="Permalink to &quot;区别总结：&quot;">​</a></h3><ol><li><p><strong>触发时机：</strong></p><ul><li>Computed：仅在相关响应式数据发生改变时才会重新求值。</li><li>Watch：监听特定数据的变化，可以在数据变化时执行自定义操作。</li></ul></li><li><p><strong>应用场景：</strong></p><ul><li>Computed：适用于依赖其他数据计算得到的属性，例如对多个数据进行计算后得出结果。</li><li>Watch：适用于需要执行异步操作或复杂逻辑处理的场景，或者监听特定数据的变化并做出响应。</li></ul></li><li><p><strong>实现方式：</strong></p><ul><li>Computed：声明为计算属性，并返回计算后的值。</li><li>Watch：通过 <code>watch</code> 选项或 <code>$watch</code> 方法来监视数据的变化并执行相应操作。</li></ul></li></ol><p>根据具体的需求和场景，可以灵活选择使用 <code>Computed</code> 还是 <code>Watch</code> 。通常来说，简单的属性计算可以使用 <code>Computed</code> ，而需要更多自定义逻辑的场景则适合使用 <code>Watch</code> 。</p></details><h2 id="vue-中的-key-有什么用" tabindex="-1">Vue 中的 key 有什么用？ <a class="header-anchor" href="#vue-中的-key-有什么用" aria-label="Permalink to &quot;Vue 中的 key 有什么用？&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><ol><li>key 是为 Vue 中 vnode 的唯一标记</li><li>key 主要用在虚拟 DOM Diff 算法，可以更高效地管理和更新 DOM</li></ol></details><h2 id="v-if和v-show的区别" tabindex="-1">v-if和v-show的区别 <a class="header-anchor" href="#v-if和v-show的区别" aria-label="Permalink to &quot;v-if和v-show的区别&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p><code>v-if</code> 和 <code>v-show</code> 都是 Vue 中用于条件渲染的指令，它们有着不同的工作原理和应用场景。</p><h3 id="v-if" tabindex="-1">v-if： <a class="header-anchor" href="#v-if" aria-label="Permalink to &quot;v-if：&quot;">​</a></h3><ul><li><strong>工作原理：</strong> <code>v-if</code> 是真正的条件渲染指令，根据表达式的真假来销毁或重建 DOM 元素。</li><li><strong>使用场景：</strong> 当表达式为真时，元素被渲染；为假时，元素被从 DOM 中移除。</li><li><strong>特点：</strong><ul><li>惰性渲染：如果初始条件为假，元素不会被渲染到 DOM 中。</li><li>每次切换时都会重新渲染：每次条件发生变化时，都会重新销毁或创建对应的 DOM 元素。</li></ul></li></ul><h3 id="v-show" tabindex="-1">v-show： <a class="header-anchor" href="#v-show" aria-label="Permalink to &quot;v-show：&quot;">​</a></h3><ul><li><strong>工作原理：</strong> <code>v-show</code> 是基于 CSS 的显示/隐藏指令，根据表达式的真假来控制元素的显示或隐藏。</li><li><strong>使用场景：</strong> 当表达式为真时，元素显示（CSS 中的 <code>display: block</code>）；为假时，元素隐藏（CSS 中的 <code>display: none</code>）。</li><li><strong>特点：</strong><ul><li>始终渲染：元素一开始就被渲染到 DOM 中，只是根据条件来显示或隐藏。</li><li>切换开销小：在元素的显示和隐藏之间切换时，不会销毁或重新创建 DOM 元素，只是通过 CSS 控制元素的显示状态。</li></ul></li></ul><h3 id="如何选择" tabindex="-1">如何选择： <a class="header-anchor" href="#如何选择" aria-label="Permalink to &quot;如何选择：&quot;">​</a></h3><ul><li>如果需要频繁切换显示状态，并且切换开销很小，可以使用 <code>v-show</code>。</li><li>如果条件不经常改变，或者需要惰性渲染，可以使用 <code>v-if</code>。</li></ul></details><h2 id="v-if和v-for不建议一起用" tabindex="-1">v-if和v-for不建议一起用 <a class="header-anchor" href="#v-if和v-for不建议一起用" aria-label="Permalink to &quot;v-if和v-for不建议一起用&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><ol><li>永远不要把 <code>v-if</code> 和 <code>v-for</code> 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）</li><li>如果避免出现这种情况，则在外层嵌套<code>template</code>（页面渲染不生成<code>dom</code>节点），在这一层进行v-if判断，然后在内部进行v-for循环</li></ol><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-if</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;isShow&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">      &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">v-for</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;item in items&quot;</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">    &lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">    &lt;</span><span style="color:#22863A;">template</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-if</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;isShow&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">      &lt;</span><span style="color:#22863A;">p</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">v-for</span><span style="color:#24292E;">=</span><span style="color:#032F62;">&quot;item in items&quot;</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">    &lt;/</span><span style="color:#22863A;">template</span><span style="color:#24292E;">&gt;</span></span></code></pre></div><ol start="3"><li>如果条件出现在循环内部，可通过计算属性<code>computed</code>提前过滤掉那些不需要显示的项</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#B392F0;">computed</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">      </span><span style="color:#B392F0;">items</span><span style="color:#E1E4E8;">: </span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.list.</span><span style="color:#B392F0;">filter</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">function</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">item</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">          </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> item.isShow</span></span>
<span class="line"><span style="color:#E1E4E8;">        })</span></span>
<span class="line"><span style="color:#E1E4E8;">      }</span></span>
<span class="line"><span style="color:#E1E4E8;">    }</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">    </span><span style="color:#6F42C1;">computed</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">      </span><span style="color:#6F42C1;">items</span><span style="color:#24292E;">: </span><span style="color:#D73A49;">function</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.list.</span><span style="color:#6F42C1;">filter</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">function</span><span style="color:#24292E;">(</span><span style="color:#E36209;">item</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">          </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> item.isShow</span></span>
<span class="line"><span style="color:#24292E;">        })</span></span>
<span class="line"><span style="color:#24292E;">      }</span></span>
<span class="line"><span style="color:#24292E;">    }</span></span></code></pre></div></details><h2 id="keep-alive-的作用和原理" tabindex="-1">keep-alive 的作用和原理 <a class="header-anchor" href="#keep-alive-的作用和原理" aria-label="Permalink to &quot;keep-alive 的作用和原理&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p><code>&lt;keep-alive&gt;</code> 可以缓存包裹在其中的组件（只能有一个直接组件），用于保存组件状态或者避免重新渲染。有三个属性</p><ul><li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li><li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li><li>max 数字，最多可以缓存多少组件实例。</li></ul><div class="language-HTML vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">HTML</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">keep-alive</span><span style="color:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#FDAEB7;font-style:italic;">Component</span><span style="color:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">keep-alive</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">&lt;</span><span style="color:#22863A;">keep-alive</span><span style="color:#24292E;">&gt;</span></span>
<span class="line"><span style="color:#24292E;">  &lt;</span><span style="color:#B31D28;font-style:italic;">Component</span><span style="color:#24292E;"> /&gt;</span></span>
<span class="line"><span style="color:#24292E;">&lt;/</span><span style="color:#22863A;">keep-alive</span><span style="color:#24292E;">&gt;</span></span></code></pre></div></details><h2 id="nexttick-的使用场景和原理" tabindex="-1">nextTick 的使用场景和原理 <a class="header-anchor" href="#nexttick-的使用场景和原理" aria-label="Permalink to &quot;nextTick 的使用场景和原理&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p><code>nextTick</code> 是 Vue 提供的一个异步更新 DOM 的方法，它可以将回调函数延迟到下次 DOM 更新循环之后执行，以获取更新后的 DOM。</p><h3 id="使用场景" tabindex="-1">使用场景： <a class="header-anchor" href="#使用场景" aria-label="Permalink to &quot;使用场景：&quot;">​</a></h3><ol><li><p><strong>DOM 更新后执行操作：</strong> 当需要在当前数据变化后立即执行某些操作，但又需要确保 DOM 已经更新完成后再执行，可以使用 <code>nextTick</code>。</p></li><li><p><strong>操作 DOM 元素：</strong> 在 Vue 生命周期钩子函数中或某些异步操作后，需要操作 DOM 元素，可以在 <code>nextTick</code> 的回调函数中进行操作，以确保获取到更新后的 DOM。</p></li></ol><h3 id="原理" tabindex="-1">原理： <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理：&quot;">​</a></h3><ol><li><p><strong>事件循环机制：</strong> <code>nextTick</code> 利用了 JavaScript 的事件循环机制，在当前执行栈执行完毕后，DOM 更新队列被清空之后，才会执行 <code>nextTick</code> 中的回调函数。</p></li><li><p><strong>微任务优先级：</strong> <code>nextTick</code> 会优先使用微任务（microtask）的方式，利用 <code>Promise</code> 或 <code>MutationObserver</code> 等浏览器原生的异步机制来执行回调，以确保在同一事件循环中更新 DOM。</p></li></ol><h3 id="示例" tabindex="-1">示例： <a class="header-anchor" href="#示例" aria-label="Permalink to &quot;示例：&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// 示例 1：在数据变化后立即执行操作</span></span>
<span class="line"><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.message </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;Updated&#39;</span></span>
<span class="line"><span style="color:#E1E4E8;">Vue.</span><span style="color:#B392F0;">nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// DOM 更新后执行的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#6A737D;">// 这里操作更新后的 DOM 元素</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 示例 2：在 Vue 生命周期钩子函数中操作 DOM 元素</span></span>
<span class="line"><span style="color:#B392F0;">mounted</span><span style="color:#E1E4E8;">() {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#79B8FF;">this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">$nextTick</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// DOM 更新后执行的操作</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// 这里操作更新后的 DOM 元素</span></span>
<span class="line"><span style="color:#E1E4E8;">  })</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// 示例 1：在数据变化后立即执行操作</span></span>
<span class="line"><span style="color:#005CC5;">this</span><span style="color:#24292E;">.message </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;Updated&#39;</span></span>
<span class="line"><span style="color:#24292E;">Vue.</span><span style="color:#6F42C1;">nextTick</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// DOM 更新后执行的操作</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6A737D;">// 这里操作更新后的 DOM 元素</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;">// 示例 2：在 Vue 生命周期钩子函数中操作 DOM 元素</span></span>
<span class="line"><span style="color:#6F42C1;">mounted</span><span style="color:#24292E;">() {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#005CC5;">this</span><span style="color:#24292E;">.</span><span style="color:#6F42C1;">$nextTick</span><span style="color:#24292E;">(() </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// DOM 更新后执行的操作</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// 这里操作更新后的 DOM 元素</span></span>
<span class="line"><span style="color:#24292E;">  })</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="注意事项" tabindex="-1">注意事项： <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项：&quot;">​</a></h3><ol><li><p><strong>异步更新：</strong> <code>nextTick</code> 中的回调函数是异步执行的，不会阻塞当前代码的执行。</p></li><li><p><strong>微任务优先：</strong> <code>nextTick</code> 会利用微任务（microtask）的方式执行，保证在同一事件循环中更新 DOM。</p></li></ol><p><code>nextTick</code> 在 Vue 中常用于获取更新后的 DOM 或在 DOM 更新后执行一些需要操作 DOM 元素的逻辑。它是保证在 Vue 更新循环结束后进行 DOM 操作的一种有效方式。</p></details><h2 id="vue生命周期" tabindex="-1">Vue生命周期 <a class="header-anchor" href="#vue生命周期" aria-label="Permalink to &quot;Vue生命周期&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>关于 Vue 生命周期的变化，可以从下表直观地了解：</p><table><thead><tr><th>Vue 2 生命周期</th><th>Vue 3 生命周期</th><th>执行时间说明</th></tr></thead><tbody><tr><td>beforeCreate</td><td>setup</td><td>组件创建前执行</td></tr><tr><td>created</td><td>setup</td><td>组件创建后执行</td></tr><tr><td>beforeMount</td><td>onBeforeMount</td><td>组件挂载到节点上之前执行</td></tr><tr><td>mounted</td><td>onMounted</td><td>组件挂载完成后执行</td></tr><tr><td>beforeUpdate</td><td>onBeforeUpdate</td><td>组件更新之前执行</td></tr><tr><td>updated</td><td>onUpdated</td><td>组件更新完成之后执行</td></tr><tr><td>beforeDestroy</td><td>onBeforeUnmount</td><td>组件卸载之前执行</td></tr><tr><td>destroyed</td><td>onUnmounted</td><td>组件卸载完成后执行</td></tr><tr><td>errorCaptured</td><td>onErrorCaptured</td><td>当捕获一个来自子孙组件的异常时激活钩子函数</td></tr></tbody></table></details><h2 id="组合式-api与选项式-api" tabindex="-1">组合式 API与选项式 API <a class="header-anchor" href="#组合式-api与选项式-api" aria-label="Permalink to &quot;组合式 API与选项式 API&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 提供了两种不同的 API 来编写组件逻辑：Options API 和 Composition API。</p><h3 id="options-api-选项式-api" tabindex="-1">Options API（选项式 API）： <a class="header-anchor" href="#options-api-选项式-api" aria-label="Permalink to &quot;Options API（选项式 API）：&quot;">​</a></h3><ul><li><strong>特点：</strong> Options API 是 Vue 2.x 中常用的 API，通过在 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 等选项中组织代码。</li><li><strong>优点：</strong><ul><li>结构清晰：将不同功能的代码分别放置在不同的选项中，易于阅读和维护。</li><li>易于入门：适合初学者，更符合直觉。</li></ul></li><li><strong>缺点：</strong><ul><li>逻辑复用困难：随着组件逻辑增加，可能导致代码复用性差，难以对逻辑进行抽象和复用。</li><li>命名冲突：当选项中的属性名冲突时，可能会造成不必要的问题。</li></ul></li></ul><h3 id="composition-api-组合式-api" tabindex="-1">Composition API（组合式 API）： <a class="header-anchor" href="#composition-api-组合式-api" aria-label="Permalink to &quot;Composition API（组合式 API）：&quot;">​</a></h3><ul><li><strong>特点：</strong> Composition API 是 Vue 3.x 新引入的 API，允许使用更灵活的函数形式组织组件逻辑。</li><li><strong>优点：</strong><ul><li>逻辑复用：更方便地将逻辑抽象为函数，并在组件间共享和复用。</li><li>代码组织：将相关的代码组织在一起，提高代码的可维护性。</li><li>更少命名冲突：由于可以使用函数封装逻辑，减少了命名冲突的可能性。</li></ul></li><li><strong>使用场景：</strong><ul><li>复杂组件：适用于大型或复杂的组件，可以更清晰地组织逻辑。</li><li>逻辑复用：对于需要在多个组件之间共享和复用逻辑的场景，Composition API 更为合适。</li></ul></li></ul><h3 id="对比总结" tabindex="-1">对比总结： <a class="header-anchor" href="#对比总结" aria-label="Permalink to &quot;对比总结：&quot;">​</a></h3><ul><li>Options API 更适合初学者和简单的组件，结构清晰易懂。</li><li>Composition API 更适合复杂的组件和逻辑复用，提供了更多灵活性和代码组织的便利性。</li></ul><p>在实际开发中，可以根据项目的需求和复杂度选择合适的 API。对于小型简单的项目，Options API 可能更为合适；对于大型复杂的项目，Composition API 则更具优势。此外，Vue 3 也允许混合使用两种 API，根据具体情况灵活选择。</p></details><h2 id="组件通信" tabindex="-1">组件通信 <a class="header-anchor" href="#组件通信" aria-label="Permalink to &quot;组件通信&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>在 Vue 中，组件之间可以通过多种方式进行通信，包括 props 和事件、Vuex 状态管理、$emit / $on 等。</p><h3 id="_1-props-和事件" tabindex="-1">1. Props 和事件： <a class="header-anchor" href="#_1-props-和事件" aria-label="Permalink to &quot;1. Props 和事件：&quot;">​</a></h3><ul><li><p><strong>Props（父子组件通信）：</strong> 父组件可以通过 props 向子组件传递数据，子组件通过 props 接收父组件传递的数据。</p></li><li><p><strong>事件（子父组件通信）：</strong> 子组件可以通过 <code>$emit</code> 触发事件并传递数据，父组件可以使用 <code>@event</code> 监听并处理子组件触发的事件。</p></li></ul><h3 id="_2-emit-on" tabindex="-1">2. $emit / $on： <a class="header-anchor" href="#_2-emit-on" aria-label="Permalink to &quot;2. $emit / $on：&quot;">​</a></h3><ul><li><strong>$emit / $on（非父子组件通信）：</strong> 通过 Vue 实例的 <code>$emit</code> 方法触发自定义事件，并在其他组件中通过 <code>$on</code> 方法监听这些事件，从而实现非父子组件之间的通信。</li></ul><h3 id="_3-eventbus" tabindex="-1">3. EventBus： <a class="header-anchor" href="#_3-eventbus" aria-label="Permalink to &quot;3. EventBus：&quot;">​</a></h3><ul><li><strong>EventBus（中央事件总线）：</strong> 可以创建一个全局的 Vue 实例作为事件总线，在组件中通过这个实例进行事件的触发和监听，实现任意组件之间的通信。</li></ul><h3 id="_4-vuex-状态管理" tabindex="-1">4. Vuex 状态管理： <a class="header-anchor" href="#_4-vuex-状态管理" aria-label="Permalink to &quot;4. Vuex 状态管理：&quot;">​</a></h3><ul><li><strong>Vuex（状态管理）：</strong> 用于在 Vue 应用中集中管理状态的库，通过 store 中的 state、mutations、actions 等来实现不同组件之间的状态共享和通信。</li></ul><ol><li><p>store 是个大容器，包含以下所有内容</p></li><li><p>State 用来读取状态，带有一个 mapState 辅助函数</p></li><li><p>Getter 用来读取派生状态，附有一个 mapGetters 辅助函数</p></li><li><p>Mutation 用于同步提交状态变更，附有一个 mapMutations 辅助函数</p></li><li><p>Action 用于异步变更状态，但它提交的是 mutation，而不是直接变更状态。</p></li><li><p>Module 用来给 store 划分模块，方便维护代码</p></li></ol><h3 id="_5-provide-inject" tabindex="-1">5. provide / inject： <a class="header-anchor" href="#_5-provide-inject" aria-label="Permalink to &quot;5. provide / inject：&quot;">​</a></h3><ul><li><strong>provide / inject（祖先后代组件通信）：</strong> 祖先组件通过 <code>provide</code> 提供数据，后代组件通过 <code>inject</code> 接收数据，实现祖先和后代组件之间的通信。</li></ul><h3 id="选择合适的通信方式" tabindex="-1">选择合适的通信方式： <a class="header-anchor" href="#选择合适的通信方式" aria-label="Permalink to &quot;选择合适的通信方式：&quot;">​</a></h3><ul><li>对于父子组件通信，props 和事件是最常用的方式。</li><li>对于非父子组件通信，可以使用 EventBus、$emit / $on 或 Vuex。</li><li>对于跨层级的通信，provide / inject 也是一种选择。</li></ul><p>在实际应用中，根据不同的场景和需求，选择合适的通信方式来实现组件之间的通信是非常重要的。</p></details><h2 id="vuerouter-用过吗-怎么理解" tabindex="-1">VueRouter 用过吗？怎么理解？ <a class="header-anchor" href="#vuerouter-用过吗-怎么理解" aria-label="Permalink to &quot;VueRouter 用过吗？怎么理解？&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>是的，VueRouter 是 Vue.js 官方的路由管理器，用于构建单页面应用（SPA）。它允许你通过简单的配置定义路由，将不同 URL 对应到 Vue 组件，实现页面间的切换和跳转。</p><h3 id="理解-vuerouter" tabindex="-1">理解 VueRouter： <a class="header-anchor" href="#理解-vuerouter" aria-label="Permalink to &quot;理解 VueRouter：&quot;">​</a></h3><ol><li><p><strong>路由配置：</strong> 在 Vue 应用中，通过创建路由实例，并定义路由规则（路由表）来配置不同 URL 对应的组件。</p></li><li><p><strong>路由跳转：</strong> 通过 <code>&lt;router-link&gt;</code> 组件或编程式的 <code>router.push</code>、<code>router.replace</code> 来进行页面间的跳转和导航。</p></li><li><p><strong>嵌套路由：</strong> 可以定义嵌套路由，通过嵌套的路由结构来管理复杂的页面结构，实现组件的嵌套和复用。</p></li><li><p><strong>路由参数传递：</strong> 支持动态路由参数，通过 <code>:id</code> 等形式进行参数传递，使得不同路由之间可以进行数据传递。</p></li><li><p><strong>导航守卫：</strong> 提供了 <code>beforeEach</code>、<code>beforeResolve</code>、<code>afterEach</code> 等导航守卫，用于全局或单个路由的导航控制和拦截。</p></li><li><p><strong>懒加载：</strong> 支持路由的懒加载，可以通过 <code>import</code> 和 ES6 的动态 import 来实现按需加载路由组件，提高性能。</p></li></ol><h3 id="使用-vuerouter-的优点" tabindex="-1">使用 VueRouter 的优点： <a class="header-anchor" href="#使用-vuerouter-的优点" aria-label="Permalink to &quot;使用 VueRouter 的优点：&quot;">​</a></h3><ul><li><p><strong>SPA 支持：</strong> VueRouter 让 Vue 应用可以更好地支持单页面应用的开发和管理。</p></li><li><p><strong>页面切换流畅：</strong> 通过路由的切换，实现页面之间的无刷新切换，提升用户体验。</p></li><li><p><strong>组件化开发：</strong> 路由的概念和 Vue 组件化开发很好地结合，使得页面的切换和管理更加清晰、灵活。</p></li><li><p><strong>导航控制：</strong> 提供了导航守卫机制，可以对路由进行全局或局部的控制和拦截，实现权限控制等功能。</p></li></ul><p>VueRouter 是 Vue.js 开发中不可或缺的一部分，它提供了一种方便、灵活的方式来管理页面路由，让前端单页面应用的开发更加便捷和高效。</p></details><h2 id="路由hash模式和history模式的区别" tabindex="-1">路由hash模式和history模式的区别 <a class="header-anchor" href="#路由hash模式和history模式的区别" aria-label="Permalink to &quot;路由hash模式和history模式的区别&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>在 Vue Router 中，路由有两种模式：Hash 模式和 History 模式。</p><h3 id="hash-模式" tabindex="-1">Hash 模式： <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;Hash 模式：&quot;">​</a></h3><ul><li><strong>URL 格式：</strong> 使用 URL 中的 <code>#</code> 来模拟整个 URL 的变化。</li><li><strong>特点：</strong><ul><li>使用 <code>window.location.hash</code> 来进行路由控制。</li><li>当 <code>#</code> 后面的内容发生变化时，不会向服务器发送请求，而是在客户端进行 hash 的变化，因此不会刷新页面。</li></ul></li><li><strong>优点：</strong><ul><li>兼容性好：支持在不支持 History API 的浏览器中使用路由。</li></ul></li><li><strong>缺点：</strong><ul><li>URL 看起来不够直观：带有 <code>#</code> 号，可能不太友好。</li><li>锚点定位问题：页面定位到锚点时会触发 hashchange 事件，可能会影响一些锚点定位的需求。</li></ul></li></ul><h3 id="history-模式" tabindex="-1">History 模式： <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;History 模式：&quot;">​</a></h3><ul><li><strong>URL 格式：</strong> 使用真实的 URL 地址，不再带有 <code>#</code>。</li><li><strong>特点：</strong><ul><li>使用 HTML5 History API 中的 <code>pushState</code> 和 <code>replaceState</code> 来实现路由控制。</li><li>更加直观、友好的 URL 形式，没有 <code>#</code> 号。</li><li>可以通过服务器配置支持在生产环境中使用。</li></ul></li><li><strong>优点：</strong><ul><li>URL 更直观：不带有 <code>#</code> 号，更符合常规网站 URL 规范，更美观。</li><li>对于支持 HTML5 History API 的浏览器，可以通过 <code>pushState</code> 和 <code>replaceState</code> 进行 URL 的操作，不会触发页面的刷新。</li></ul></li><li><strong>缺点：</strong><ul><li>兼容性问题：不支持 HTML5 History API 的浏览器会导致路由失效，需要服务器进行配置支持。</li></ul></li></ul><h3 id="如何选择模式" tabindex="-1">如何选择模式： <a class="header-anchor" href="#如何选择模式" aria-label="Permalink to &quot;如何选择模式：&quot;">​</a></h3><ul><li>如果对浏览器兼容性要求较高，或者项目不需要考虑服务端渲染，并且对 URL 形式不敏感，可以选择 Hash 模式。</li><li>如果希望 URL 更加直观美观，并且不考虑对不支持 HTML5 History API 的浏览器进行支持，可以选择 History 模式。</li></ul><p>通常情况下，根据项目需求和实际情况来选择合适的路由模式，以提供更好的用户体验。</p></details><h2 id="vue-3-x-带来了哪些新的特性和性能方面的提升" tabindex="-1">Vue 3.x 带来了哪些新的特性和性能方面的提升 <a class="header-anchor" href="#vue-3-x-带来了哪些新的特性和性能方面的提升" aria-label="Permalink to &quot;Vue 3.x 带来了哪些新的特性和性能方面的提升&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 3.x 带来了许多新的特性和性能方面的提升，其中一些重要的变化和改进包括：</p><h3 id="_1-composition-api-组合式-api" tabindex="-1">1. Composition API（组合式 API）： <a class="header-anchor" href="#_1-composition-api-组合式-api" aria-label="Permalink to &quot;1. Composition API（组合式 API）：&quot;">​</a></h3><ul><li><strong>更灵活的组件逻辑复用：</strong> 提供了 Composition API，使得组件逻辑更易于抽象、复用和组合。</li><li><strong>逻辑关注点更清晰：</strong> 允许按功能组织逻辑而不是选项，使得代码更易于阅读和维护。</li></ul><h3 id="_2-更好的-typescript-支持" tabindex="-1">2. 更好的 TypeScript 支持： <a class="header-anchor" href="#_2-更好的-typescript-支持" aria-label="Permalink to &quot;2. 更好的 TypeScript 支持：&quot;">​</a></h3><ul><li><strong>更完善的类型推断：</strong> Vue 3 对 TypeScript 支持更加完善，提供了更好的类型推断和支持，使得开发时更加友好和高效。</li></ul><h3 id="_3-更快的渲染性能" tabindex="-1">3. 更快的渲染性能： <a class="header-anchor" href="#_3-更快的渲染性能" aria-label="Permalink to &quot;3. 更快的渲染性能：&quot;">​</a></h3><ul><li><strong>虚拟 DOM 优化：</strong> 使用了更高效的虚拟 DOM 渲染策略，提升了渲染性能。</li><li><strong>Tree-Shaking 支持：</strong> 改进了 Tree-Shaking 的支持，减小了打包体积，提高了加载速度。</li></ul><h3 id="_4-新的-api-设计" tabindex="-1">4. 新的 API 设计： <a class="header-anchor" href="#_4-新的-api-设计" aria-label="Permalink to &quot;4. 新的 API 设计：&quot;">​</a></h3><ul><li><strong>更简洁的 API：</strong> 优化了一些 API 的设计，使得使用更简洁、直观。</li><li><strong>更直观的生命周期：</strong> 简化了生命周期，让开发者更容易理解和使用。</li></ul><h3 id="_5-其他改进" tabindex="-1">5. 其他改进： <a class="header-anchor" href="#_5-其他改进" aria-label="Permalink to &quot;5. 其他改进：&quot;">​</a></h3><ul><li><strong>更好的 TypeScript 支持：</strong> Vue 3 对 TypeScript 支持更加完善，提供了更好的类型推断和支持，使得开发时更加友好和高效。</li><li><strong>响应式系统优化：</strong> 对响应式系统进行了重构和优化，提高了响应式数据的性能和稳定性。</li></ul><p>这些改进使得 Vue 3 在性能、开发体验和灵活性等方面都有了显著的提升，为开发者提供了更好的开发体验和更高效的开发方式。</p></details><h2 id="vue-3-为什么使用-proxy" tabindex="-1">Vue 3 为什么使用 Proxy <a class="header-anchor" href="#vue-3-为什么使用-proxy" aria-label="Permalink to &quot;Vue 3 为什么使用 Proxy&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 3 使用 Proxy 主要是为了改进其响应式系统。在 Vue 2 中，Vue 使用了 Object.defineProperty 来实现数据的响应式。但在某些情况下，Object.defineProperty 存在一些限制和不足，因此 Vue 3 选择了 Proxy 作为替代方案来提升响应式系统的性能和灵活性。</p><h3 id="proxy-的优势" tabindex="-1">Proxy 的优势： <a class="header-anchor" href="#proxy-的优势" aria-label="Permalink to &quot;Proxy 的优势：&quot;">​</a></h3><ol><li><p><strong>更全面的拦截能力：</strong> Proxy 提供了更丰富和灵活的拦截能力，可以覆盖几乎所有对象操作，包括 get、set、delete、has、defineProperty 等，而 Object.defineProperty 只能拦截部分操作。</p></li><li><p><strong>更直观的语法和操作：</strong> 使用 Proxy 可以更直观地定义拦截操作，提高了代码的可读性和维护性，比起 Object.defineProperty 更易于理解和使用。</p></li><li><p><strong>性能提升：</strong> 在某些场景下，Proxy 比 Object.defineProperty 具有更好的性能。由于 Proxy 是在语言层面实现的，有更高效的底层实现，可以带来一些性能上的优势。</p></li><li><p><strong>更好的嵌套支持：</strong> Proxy 对象本身可以是响应式的，这使得嵌套对象的响应式追踪更加简单和直观。</p></li></ol><h3 id="为什么不使用-object-defineproperty" tabindex="-1">为什么不使用 Object.defineProperty？ <a class="header-anchor" href="#为什么不使用-object-defineproperty" aria-label="Permalink to &quot;为什么不使用 Object.defineProperty？&quot;">​</a></h3><p>虽然 Object.defineProperty 在 Vue 2 中被广泛使用，但它存在一些限制：</p><ul><li><p><strong>无法完全拦截数组操作：</strong> 对于数组的一些变更操作（例如直接通过索引修改值），Object.defineProperty 无法完全拦截，需要额外的处理来实现响应式。</p></li><li><p><strong>初始化数据时的限制：</strong> Object.defineProperty 需要在初始化时递归遍历对象，并对每个属性进行 defineProperty 操作，这个过程可能会影响性能。</p></li><li><p><strong>Proxy 的灵活性和拦截能力更强：</strong> 相比之下，Proxy 提供了更全面和灵活的拦截能力，更符合 Vue 3 对于响应式系统的要求。</p></li></ul><p>综上所述，Vue 3 使用 Proxy 替代 Object.defineProperty 主要是为了提供更强大、更灵活的响应式系统，带来更好的性能和开发体验。</p></details><h2 id="vue-2-和-vue-3-diff算法区别" tabindex="-1">Vue 2 和 Vue 3 Diff算法区别 <a class="header-anchor" href="#vue-2-和-vue-3-diff算法区别" aria-label="Permalink to &quot;Vue 2 和 Vue 3 Diff算法区别&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 2 和 Vue 3 在 Virtual DOM 的 diff 算法上有一些区别，让我们分别看一下它们的原理：</p><h3 id="vue-2-的-virtual-dom-和-diff-算法" tabindex="-1">Vue 2 的 Virtual DOM 和 Diff 算法 <a class="header-anchor" href="#vue-2-的-virtual-dom-和-diff-算法" aria-label="Permalink to &quot;Vue 2 的 Virtual DOM 和 Diff 算法&quot;">​</a></h3><h4 id="virtual-dom" tabindex="-1">Virtual DOM <a class="header-anchor" href="#virtual-dom" aria-label="Permalink to &quot;Virtual DOM&quot;">​</a></h4><p>在 Vue 2 中，Virtual DOM 是通过使用虚拟节点树来表示真实 DOM 结构的抽象表示。当状态发生变化时，Vue 2 会创建一个新的虚拟节点树，然后与之前的虚拟节点树进行比较。</p><h4 id="diff-算法" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h4><p>Vue 2 中使用的是经典的 Virtual DOM Diff 算法，即采用了<strong>双端比较</strong>的策略，也称为**O(n^3)**的算法。该算法的时间复杂度比较高，特别是在节点较多的情况下，可能会造成性能问题。</p><ol><li><strong>Diff 策略：</strong><ul><li>首先对比新旧虚拟节点的根节点，根据节点类型做出相应的更新操作（创建、删除、替换等）。</li><li>如果根节点相同，继续对比其子节点。</li><li>遍历子节点时，采用双指针的方式进行比较，逐层对比子节点，找出需要更新的节点。</li><li>Diff 算法对比节点的过程并不智能，它在每次更新时都会对整个节点树进行比较，这样做在节点较多的情况下会消耗大量的计算资源。</li></ul></li></ol><h3 id="vue-3-的-virtual-dom-和-diff-算法" tabindex="-1">Vue 3 的 Virtual DOM 和 Diff 算法 <a class="header-anchor" href="#vue-3-的-virtual-dom-和-diff-算法" aria-label="Permalink to &quot;Vue 3 的 Virtual DOM 和 Diff 算法&quot;">​</a></h3><h4 id="virtual-dom-1" tabindex="-1">Virtual DOM <a class="header-anchor" href="#virtual-dom-1" aria-label="Permalink to &quot;Virtual DOM&quot;">​</a></h4><p>在 Vue 3 中，Virtual DOM 仍然是一个抽象的虚拟节点树，但引入了一种名为“静态树提升”（Static Tree Hoisting）的优化技术，该技术可以将一些静态节点标记为常量，避免不必要的比较和渲染。</p><h4 id="diff-算法-1" tabindex="-1">Diff 算法 <a class="header-anchor" href="#diff-算法-1" aria-label="Permalink to &quot;Diff 算法&quot;">​</a></h4><p>Vue 3 引入了<strong>优化过的 Diff 算法</strong>，主要基于**<code>ES6 Map</code>** 的数据结构进行优化，具体包括<strong>递归更新</strong>、<strong>缓存节点</strong>和<strong>按键（key）的比较</strong>等方面。Vue 3 的 Diff 算法主要优化了以下几个方面：</p><ol><li><p><strong>按键（key）的比较：</strong></p><ul><li>Vue 3 在 Diff 算法中更加重视节点的 <code>key</code> ，以更精确地匹配新旧节点，避免不必要的 DOM 操作。</li><li>使用 <code>key</code> 可以帮助 Vue 3 跟踪节点的变化，使得在列表中插入、移动、删除节点时效率更高。</li></ul></li><li><p><strong>递归更新：</strong></p><ul><li>Vue 3 的 Diff 算法会在更新过程中进行递归，只对有变化的子节点进行比较，而不是整体遍历整个节点树。</li></ul></li><li><p><strong>缓存节点：</strong></p><ul><li>Vue 3 会缓存节点的信息，比如节点的索引和 key 值，以便更快地进行对比和更新。</li></ul></li></ol><p>总体来说，Vue 3 的 Diff 算法相对于 Vue 2 有更多的优化，能够更加智能地比较节点变化，减少不必要的 DOM 操作，提高了性能和效率。</p></details><h2 id="vue-和-react-的区别" tabindex="-1">Vue 和 React 的区别？ <a class="header-anchor" href="#vue-和-react-的区别" aria-label="Permalink to &quot;Vue 和 React 的区别？&quot;">​</a></h2><details class="details custom-block"><summary>答案</summary><p>Vue 和 React 是两个流行的前端框架/库，它们在一些方面有一些显著的区别：</p><h3 id="_1-设计理念和语法风格" tabindex="-1">1. 设计理念和语法风格 <a class="header-anchor" href="#_1-设计理念和语法风格" aria-label="Permalink to &quot;1. 设计理念和语法风格&quot;">​</a></h3><ul><li><strong>Vue</strong>：更加自然和简洁的模板语法，使用指令（比如 <code>v-for</code>、<code>v-if</code> 等）来处理模板中的逻辑。Vue 更加接近传统的 HTML/CSS/JS 开发方式，容易上手。</li><li><strong>React</strong>：使用 JSX（JavaScript XML）作为模板语言，将 HTML 结构直接写在 JavaScript 代码中。JSX 使得组件逻辑与渲染的描述更加紧密，允许编写复杂的模板逻辑。</li></ul><h3 id="_2-组件化和状态管理" tabindex="-1">2. 组件化和状态管理 <a class="header-anchor" href="#_2-组件化和状态管理" aria-label="Permalink to &quot;2. 组件化和状态管理&quot;">​</a></h3><ul><li><strong>Vue</strong>：提供了单文件组件（SFC）的概念，将模板、样式和逻辑组织在一个文件中。Vue 的状态管理可以通过内置的 Vuex 来管理应用的状态。</li><li><strong>React</strong>：支持组件化开发，但官方库较少，通常需要使用第三方库（如 Redux）来进行状态管理。React 的设计更侧重于组件之间的通信和状态提升。</li></ul><h3 id="_3-生命周期和响应式" tabindex="-1">3. 生命周期和响应式 <a class="header-anchor" href="#_3-生命周期和响应式" aria-label="Permalink to &quot;3. 生命周期和响应式&quot;">​</a></h3><ul><li><strong>Vue</strong>：拥有明确的生命周期钩子，开发者可以在组件的不同阶段插入逻辑。Vue 使用了响应式的数据绑定，当数据发生变化时，会自动更新视图。</li><li><strong>React</strong>：没有像 Vue 那样的生命周期钩子，但提供了 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 等方法。React 使用了 Virtual DOM 来提高性能，当状态发生变化时，通过 Diff 算法更新真实 DOM。</li></ul><h3 id="_4-社区和生态系统" tabindex="-1">4. 社区和生态系统 <a class="header-anchor" href="#_4-社区和生态系统" aria-label="Permalink to &quot;4. 社区和生态系统&quot;">​</a></h3><ul><li><strong>Vue</strong>：相对较小但不断增长的社区，生态系统不如 React 大。Vue 的插件和库数量在逐渐增加，但仍然较少。</li><li><strong>React</strong>：拥有庞大的社区和生态系统，许多大型公司在生产环境中使用 React，有大量的第三方库和工具可供选择。</li></ul><h3 id="_5-学习曲线和上手难度" tabindex="-1">5. 学习曲线和上手难度 <a class="header-anchor" href="#_5-学习曲线和上手难度" aria-label="Permalink to &quot;5. 学习曲线和上手难度&quot;">​</a></h3><ul><li><strong>Vue</strong>：上手相对容易，更直观和易懂的模板语法使得初学者更容易理解。</li><li><strong>React</strong>：JSX 可能对新手来说有一定的学习曲线，需要适应将 HTML 结构与 JavaScript 代码混合编写。</li></ul><p>总体而言，Vue 和 React 都是优秀的前端框架/库，选择哪个取决于项目需求、个人偏好以及团队的技术栈和经验。两者在组件化、状态管理和响应式等方面有所不同，开发者可以根据自己的喜好和项目需求做出选择。</p></details>`,40),n=[t];function i(r,p,c,d,u,h){return e(),s("div",null,n)}const g=a(o,[["render",i]]);export{m as __pageData,g as default};
