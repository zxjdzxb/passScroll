# Vue

## 谈谈你对 Vue 的理解？为什么使用 Vue 进行开发？

::: details
1. Vue 对于前端初学者比较友好。一个 Vue 文件的结构和原生 HTML 保持了高度相似，分为静态页面，用于放置 html 标签，和 script，用于处理用户操作和业务逻辑，最后是 style 样式，用于书写 CSS 代码，这种写法可以让初学者感到习惯。

2. Vue 提供了许多 JS 定制化的操作，比如 v-bind 和事件监听的 @ 符号，开发者可以直接使用，从而减少一些重复代码的书写。

3. Vue 提供一套高效的响应式的系统用于更新 DOM，可以让开发者专注于处理业务而非技术实现。

4. Vue 鼓励组件化开发，开发者可以将部分界面提取为组件，尤其是复用性较高的界面，使代码更加模块化、可维护性更高。

5. Vue 在国内拥有庞大且活跃的社区，开发者可以获得丰富的文档、教程、插件和支持。
:::

## MVVM

MVVM，即 Model–View–ViewModel，是一种软件架构模式。
::: details
* Model
即模型，是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。

* View
即视图，是用户在屏幕上看到的结构、布局和外观（UI）。

* ViewModel
即视图模型，是暴露公共属性和命令的视图的抽象。用于把 Model 和 View 关联起来。ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model 。
:::

## Vue 响应式系统的原理

::: details
Vue 实现响应式主要是采用数据劫持结合发布者-订阅者模式的方式。具体实现就是整合 Observer，Compiler 和 Watcher 三者。
* Observer
 <!---->
在 Vue 2 中是通过 ES5 的 Object.defineProperty() 方法实现。

在 Vue 3 中是通过 ES6 的 new Proxy() 实现的。
* Compiler
 <!---->

模板编译器。它的作用是对每个元素节点的指令 v- 和模板语法 {{}} 进行扫描，替换对应的真实数据，或绑定相应的事件函数。
* Watcher
 <!---->
发布者/订阅者。Watcher 作为连接 Observer 和 Compiler 的桥梁，能够订阅并收到每个属性变动的通知，然后执行相应的回调函数。Compiler 在编译时通过 Watcher 绑定对应的数据更新回调函数，Observer 在监听到数据变化时执行此回调。在 Observer 中，Watcher 就是订阅者，在 Compiler 中，Watcher 就是发布者。

:::

## Vue 是如何实现数据双向绑定的？v-model 的原理？

::: details
Vue 组件可以通过使用 v-model 指令以实现双向绑定。
v-model 是 vue 的一个语法糖，它用于监听数据的改变并将数据更新。以 input 元素为例：

```HTML
<el-input v-model="foo" />
```

其实就等价于

```HTML
<input :value="searchText" @input="searchText = $event.target.value" />
```

:::
 ## Computed 和 Watch 的区别
::: details
`Computed` 和 `Watch` 是 Vue 中用于观察数据变化并执行相应操作的两种主要方式，它们有着不同的应用场景和工作方式。

### Computed（计算属性）：

* **用途：** 计算属性用于根据已有的数据计算出一个新的属性，并将这个属性缓存起来，只有依赖的响应式数据发生变化时才会重新计算。
* **声明方式：** 使用 `computed` 对象声明计算属性。
* **特点：**
  + 缓存：计算属性会缓存计算结果，在依赖数据不变的情况下不会重新计算。
  + 响应性：计算属性依赖于响应式数据，当依赖数据变化时，计算属性会重新计算。
  + 计算开销：适合进行复杂的计算操作，避免在模板中写复杂的逻辑。

### Watch（侦听器）：

* **用途：** Watch 用于观察和响应特定数据的变化，可以执行自定义的操作，例如异步操作或复杂逻辑处理。
* **声明方式：** 使用 `watch` 选项或者 `$watch` 方法来声明一个观察者。
* **特点：**
  + 灵活性：能够监听任何数据的变化，包括对象、数组的变化，以及深度监听。
  + 异步操作：可以在数据变化时执行异步操作或复杂的业务逻辑。

### 区别总结：

1. **触发时机：**
   - Computed：仅在相关响应式数据发生改变时才会重新求值。
   - Watch：监听特定数据的变化，可以在数据变化时执行自定义操作。

2. **应用场景：**
   - Computed：适用于依赖其他数据计算得到的属性，例如对多个数据进行计算后得出结果。
   - Watch：适用于需要执行异步操作或复杂逻辑处理的场景，或者监听特定数据的变化并做出响应。

3. **实现方式：**
   - Computed：声明为计算属性，并返回计算后的值。
   - Watch：通过 `watch` 选项或 `$watch` 方法来监视数据的变化并执行相应操作。

根据具体的需求和场景，可以灵活选择使用 `Computed` 还是 `Watch` 。通常来说，简单的属性计算可以使用 `Computed` ，而需要更多自定义逻辑的场景则适合使用 `Watch` 。
:::

## Vue 中的 key 有什么用？

::: details
1. key 是为 Vue 中 vnode 的唯一标记
2. key 主要用在虚拟 DOM Diff 算法，可以更高效地管理和更新 DOM
:::

## v-if和v-show的区别

::: details
`v-if` 和 `v-show` 都是 Vue 中用于条件渲染的指令，它们有着不同的工作原理和应用场景。

### v-if：

* **工作原理：** `v-if` 是真正的条件渲染指令，根据表达式的真假来销毁或重建 DOM 元素。
* **使用场景：** 当表达式为真时，元素被渲染；为假时，元素被从 DOM 中移除。
* **特点：**
  + 惰性渲染：如果初始条件为假，元素不会被渲染到 DOM 中。
  + 每次切换时都会重新渲染：每次条件发生变化时，都会重新销毁或创建对应的 DOM 元素。

### v-show：

* **工作原理：** `v-show` 是基于 CSS 的显示/隐藏指令，根据表达式的真假来控制元素的显示或隐藏。
* **使用场景：** 当表达式为真时，元素显示（CSS 中的 `display: block`）；为假时，元素隐藏（CSS 中的 `display: none`）。
* **特点：**
  + 始终渲染：元素一开始就被渲染到 DOM 中，只是根据条件来显示或隐藏。
  + 切换开销小：在元素的显示和隐藏之间切换时，不会销毁或重新创建 DOM 元素，只是通过 CSS 控制元素的显示状态。

### 如何选择：

* 如果需要频繁切换显示状态，并且切换开销很小，可以使用 `v-show`。
* 如果条件不经常改变，或者需要惰性渲染，可以使用 `v-if`。

总的来说， `v-if` 适合在需要进行频繁切换的情况下，而 `v-show` 适合在需要初始渲染时就保留元素，并且切换开销很小的情况下使用。
:::

## v-if和v-for不建议一起用

::: details

`v-if`  指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回  `true` 值的时候被渲染

`v-for`  指令基于一个数组来渲染一个列表。 `v-for`  指令需要使用  `item in items`  形式的特殊语法，其中  `items`  是源数据数组或者对象，而  `item`  则是被迭代的数组元素的别名

在  `v-for`  的时候，建议设置 `key` 值，并且保证每个 `key` 值是独一无二的，这便于 `diff` 算法进行优化

1.  永远不要把 `v-if` 和 `v-for` 同时用在同一个元素上，带来性能方面的浪费（每次渲染都会先循环再进行条件判断）
2.  如果避免出现这种情况，则在外层嵌套`template`（页面渲染不生成`dom`节点），在这一层进行v-if判断，然后在内部进行v-for循环

<!---->

```html
    <template v-if="isShow">
      <p v-for="item in items">
    </template>
```

3.  如果条件出现在循环内部，可通过计算属性`computed`提前过滤掉那些不需要显示的项

<!---->

```js
    computed: {
      items: function() {
        return this.list.filter(function(item) {
          return item.isShow
        })
      }
    }
```

 :::

## keep-alive 的作用和原理

::: details
`<keep-alive>` 可以缓存包裹在其中的组件（只能有一个直接组件），用于保存组件状态或者避免重新渲染。有三个属性
* include 字符串或正则表达式，只有名称匹配的组件会被匹配；
* exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；
* max 数字，最多可以缓存多少组件实例。

```HTML
<keep-alive>
  <Component />
</keep-alive>
```

:::

## nextTick 的使用场景和原理

::: details
`nextTick` 是 Vue 提供的一个异步更新 DOM 的方法，它可以将回调函数延迟到下次 DOM 更新循环之后执行，以获取更新后的 DOM。

### 使用场景：

1. **DOM 更新后执行操作：** 当需要在当前数据变化后立即执行某些操作，但又需要确保 DOM 已经更新完成后再执行，可以使用 `nextTick`。

2. **操作 DOM 元素：** 在 Vue 生命周期钩子函数中或某些异步操作后，需要操作 DOM 元素，可以在 `nextTick` 的回调函数中进行操作，以确保获取到更新后的 DOM。

### 原理：

1. **事件循环机制：** `nextTick` 利用了 JavaScript 的事件循环机制，在当前执行栈执行完毕后，DOM 更新队列被清空之后，才会执行 `nextTick` 中的回调函数。

2. **微任务优先级：** `nextTick` 会优先使用微任务（microtask）的方式，利用 `Promise` 或 `MutationObserver` 等浏览器原生的异步机制来执行回调，以确保在同一事件循环中更新 DOM。

### 示例：

```javascript
// 示例 1：在数据变化后立即执行操作
this.message = 'Updated'
Vue.nextTick(() => {
  // DOM 更新后执行的操作
  // 这里操作更新后的 DOM 元素
})

// 示例 2：在 Vue 生命周期钩子函数中操作 DOM 元素
mounted() {
  this.$nextTick(() => {
    // DOM 更新后执行的操作
    // 这里操作更新后的 DOM 元素
  })
}
```

### 注意事项：

1. **异步更新：** `nextTick` 中的回调函数是异步执行的，不会阻塞当前代码的执行。

2. **微任务优先：** `nextTick` 会利用微任务（microtask）的方式执行，保证在同一事件循环中更新 DOM。

`nextTick` 在 Vue 中常用于获取更新后的 DOM 或在 DOM 更新后执行一些需要操作 DOM 元素的逻辑。它是保证在 Vue 更新循环结束后进行 DOM 操作的一种有效方式。
:::

## Vue生命周期

::: details
关于 Vue 生命周期的变化，可以从下表直观地了解：

| Vue 2 生命周期    | Vue 3 生命周期      | 执行时间说明                |
| ------------- | --------------- | --------------------- |
| beforeCreate  | setup           | 组件创建前执行               |
| created       | setup           | 组件创建后执行               |
| beforeMount   | onBeforeMount   | 组件挂载到节点上之前执行          |
| mounted       | onMounted       | 组件挂载完成后执行             |
| beforeUpdate  | onBeforeUpdate  | 组件更新之前执行              |
| updated       | onUpdated       | 组件更新完成之后执行            |
| beforeDestroy | onBeforeUnmount | 组件卸载之前执行              |
| destroyed     | onUnmounted     | 组件卸载完成后执行             |
| errorCaptured | onErrorCaptured | 当捕获一个来自子孙组件的异常时激活钩子函数 |
:::

## 组合式 API与选项式 API

::: details
Vue 提供了两种不同的 API 来编写组件逻辑：Options API 和 Composition API。

### Options API（选项式 API）：

* **特点：** Options API 是 Vue 2.x 中常用的 API，通过在 `data`、`methods`、`computed`、`watch` 等选项中组织代码。
* **优点：**
  + 结构清晰：将不同功能的代码分别放置在不同的选项中，易于阅读和维护。
  + 易于入门：适合初学者，更符合直觉。
* **缺点：**
  + 逻辑复用困难：随着组件逻辑增加，可能导致代码复用性差，难以对逻辑进行抽象和复用。
  + 命名冲突：当选项中的属性名冲突时，可能会造成不必要的问题。

### Composition API（组合式 API）：

* **特点：** Composition API 是 Vue 3.x 新引入的 API，允许使用更灵活的函数形式组织组件逻辑。
* **优点：**
  + 逻辑复用：更方便地将逻辑抽象为函数，并在组件间共享和复用。
  + 代码组织：将相关的代码组织在一起，提高代码的可维护性。
  + 更少命名冲突：由于可以使用函数封装逻辑，减少了命名冲突的可能性。
* **使用场景：**
  + 复杂组件：适用于大型或复杂的组件，可以更清晰地组织逻辑。
  + 逻辑复用：对于需要在多个组件之间共享和复用逻辑的场景，Composition API 更为合适。

### 对比总结：

* Options API 更适合初学者和简单的组件，结构清晰易懂。
* Composition API 更适合复杂的组件和逻辑复用，提供了更多灵活性和代码组织的便利性。

在实际开发中，可以根据项目的需求和复杂度选择合适的 API。对于小型简单的项目，Options API 可能更为合适；对于大型复杂的项目，Composition API 则更具优势。此外，Vue 3 也允许混合使用两种 API，根据具体情况灵活选择。
:::

## 组件通信

::: details
在 Vue 中，组件之间可以通过多种方式进行通信，包括 props 和事件、Vuex 状态管理、$emit / $on 等。

### 1. Props 和事件：

* **Props（父子组件通信）：** 父组件可以通过 props 向子组件传递数据，子组件通过 props 接收父组件传递的数据。

* **事件（子父组件通信）：** 子组件可以通过 `$emit` 触发事件并传递数据，父组件可以使用 `@event` 监听并处理子组件触发的事件。

### 2. $emit / $on：

* **$emit / $on（非父子组件通信）：** 通过 Vue 实例的 `$emit` 方法触发自定义事件，并在其他组件中通过 `$on` 方法监听这些事件，从而实现非父子组件之间的通信。

### 3. EventBus：

* **EventBus（中央事件总线）：** 可以创建一个全局的 Vue 实例作为事件总线，在组件中通过这个实例进行事件的触发和监听，实现任意组件之间的通信。

### 4. Vuex 状态管理：

* **Vuex（状态管理）：** 用于在 Vue 应用中集中管理状态的库，通过 store 中的 state、mutations、actions 等来实现不同组件之间的状态共享和通信。

1. store 是个大容器，包含以下所有内容

2. State 用来读取状态，带有一个 mapState 辅助函数

3. Getter 用来读取派生状态，附有一个 mapGetters 辅助函数

4. Mutation 用于同步提交状态变更，附有一个 mapMutations 辅助函数

5. Action 用于异步变更状态，但它提交的是 mutation，而不是直接变更状态。

6. Module 用来给 store 划分模块，方便维护代码

### 5. provide / inject：

* **provide / inject（祖先后代组件通信）：** 祖先组件通过 `provide` 提供数据，后代组件通过 `inject` 接收数据，实现祖先和后代组件之间的通信。

### 选择合适的通信方式：

* 对于父子组件通信，props 和事件是最常用的方式。
* 对于非父子组件通信，可以使用 EventBus、$emit / $on 或 Vuex。
* 对于跨层级的通信，provide / inject 也是一种选择。

在实际应用中，根据不同的场景和需求，选择合适的通信方式来实现组件之间的通信是非常重要的。
:::

## VueRouter 用过吗？怎么理解？

::: details
是的，VueRouter 是 Vue.js 官方的路由管理器，用于构建单页面应用（SPA）。它允许你通过简单的配置定义路由，将不同 URL 对应到 Vue 组件，实现页面间的切换和跳转。

### 理解 VueRouter：

1. **路由配置：** 在 Vue 应用中，通过创建路由实例，并定义路由规则（路由表）来配置不同 URL 对应的组件。

2. **路由跳转：** 通过 `<router-link>` 组件或编程式的 `router.push`、`router.replace` 来进行页面间的跳转和导航。

3. **嵌套路由：** 可以定义嵌套路由，通过嵌套的路由结构来管理复杂的页面结构，实现组件的嵌套和复用。

4. **路由参数传递：** 支持动态路由参数，通过 `:id` 等形式进行参数传递，使得不同路由之间可以进行数据传递。

5. **导航守卫：** 提供了 `beforeEach`、`beforeResolve`、`afterEach` 等导航守卫，用于全局或单个路由的导航控制和拦截。

6. **懒加载：** 支持路由的懒加载，可以通过 `import` 和 ES6 的动态 import 来实现按需加载路由组件，提高性能。

### 使用 VueRouter 的优点：

* **SPA 支持：** VueRouter 让 Vue 应用可以更好地支持单页面应用的开发和管理。

* **页面切换流畅：** 通过路由的切换，实现页面之间的无刷新切换，提升用户体验。

* **组件化开发：** 路由的概念和 Vue 组件化开发很好地结合，使得页面的切换和管理更加清晰、灵活。

* **导航控制：** 提供了导航守卫机制，可以对路由进行全局或局部的控制和拦截，实现权限控制等功能。

VueRouter 是 Vue.js 开发中不可或缺的一部分，它提供了一种方便、灵活的方式来管理页面路由，让前端单页面应用的开发更加便捷和高效。
:::

## 路由hash模式和history模式的区别

::: details
在 Vue Router 中，路由有两种模式：Hash 模式和 History 模式。

### Hash 模式：

* **URL 格式：** 使用 URL 中的 `#` 来模拟整个 URL 的变化。
* **特点：**
  + 使用 `window.location.hash` 来进行路由控制。
  + 当 `#` 后面的内容发生变化时，不会向服务器发送请求，而是在客户端进行 hash 的变化，因此不会刷新页面。
* **优点：**
  + 兼容性好：支持在不支持 History API 的浏览器中使用路由。
* **缺点：**
  + URL 看起来不够直观：带有 `#` 号，可能不太友好。
  + 锚点定位问题：页面定位到锚点时会触发 hashchange 事件，可能会影响一些锚点定位的需求。

### History 模式：

* **URL 格式：** 使用真实的 URL 地址，不再带有 `#`。
* **特点：**
  + 使用 HTML5 History API 中的 `pushState` 和 `replaceState` 来实现路由控制。
  + 更加直观、友好的 URL 形式，没有 `#` 号。
  + 可以通过服务器配置支持在生产环境中使用。
* **优点：**
  + URL 更直观：不带有 `#` 号，更符合常规网站 URL 规范，更美观。
  + 对于支持 HTML5 History API 的浏览器，可以通过 `pushState` 和 `replaceState` 进行 URL 的操作，不会触发页面的刷新。
* **缺点：**
  + 兼容性问题：不支持 HTML5 History API 的浏览器会导致路由失效，需要服务器进行配置支持。

### 如何选择模式：

* 如果对浏览器兼容性要求较高，或者项目不需要考虑服务端渲染，并且对 URL 形式不敏感，可以选择 Hash 模式。
* 如果希望 URL 更加直观美观，并且不考虑对不支持 HTML5 History API 的浏览器进行支持，可以选择 History 模式。

通常情况下，根据项目需求和实际情况来选择合适的路由模式，以提供更好的用户体验。
:::

## Vue 3.x 带来了哪些新的特性和性能方面的提升

::: details
Vue 3.x 带来了许多新的特性和性能方面的提升，其中一些重要的变化和改进包括：

### 1. Composition API（组合式 API）：

* **更灵活的组件逻辑复用：** 提供了 Composition API，使得组件逻辑更易于抽象、复用和组合。
* **逻辑关注点更清晰：** 允许按功能组织逻辑而不是选项，使得代码更易于阅读和维护。

### 2. 更好的 TypeScript 支持：

* **更完善的类型推断：** Vue 3 对 TypeScript 支持更加完善，提供了更好的类型推断和支持，使得开发时更加友好和高效。

### 3. 更快的渲染性能：

* **虚拟 DOM 优化：** 使用了更高效的虚拟 DOM 渲染策略，提升了渲染性能。
* **Tree-Shaking 支持：** 改进了 Tree-Shaking 的支持，减小了打包体积，提高了加载速度。

### 4. 新的 API 设计：

* **更简洁的 API：** 优化了一些 API 的设计，使得使用更简洁、直观。
* **更直观的生命周期：** 简化了生命周期，让开发者更容易理解和使用。

### 5. 其他改进：

* **更好的 TypeScript 支持：** Vue 3 对 TypeScript 支持更加完善，提供了更好的类型推断和支持，使得开发时更加友好和高效。
* **响应式系统优化：** 对响应式系统进行了重构和优化，提高了响应式数据的性能和稳定性。

这些改进使得 Vue 3 在性能、开发体验和灵活性等方面都有了显著的提升，为开发者提供了更好的开发体验和更高效的开发方式。
:::

## Vue 3 为什么使用 Proxy

::: details
Vue 3 使用 Proxy 主要是为了改进其响应式系统。在 Vue 2 中，Vue 使用了 Object.defineProperty 来实现数据的响应式。但在某些情况下，Object.defineProperty 存在一些限制和不足，因此 Vue 3 选择了 Proxy 作为替代方案来提升响应式系统的性能和灵活性。

### Proxy 的优势：

1. **更全面的拦截能力：** Proxy 提供了更丰富和灵活的拦截能力，可以覆盖几乎所有对象操作，包括 get、set、delete、has、defineProperty 等，而 Object.defineProperty 只能拦截部分操作。

2. **更直观的语法和操作：** 使用 Proxy 可以更直观地定义拦截操作，提高了代码的可读性和维护性，比起 Object.defineProperty 更易于理解和使用。

3. **性能提升：** 在某些场景下，Proxy 比 Object.defineProperty 具有更好的性能。由于 Proxy 是在语言层面实现的，有更高效的底层实现，可以带来一些性能上的优势。

4. **更好的嵌套支持：** Proxy 对象本身可以是响应式的，这使得嵌套对象的响应式追踪更加简单和直观。

### 为什么不使用 Object.defineProperty？

虽然 Object.defineProperty 在 Vue 2 中被广泛使用，但它存在一些限制：

* **无法完全拦截数组操作：** 对于数组的一些变更操作（例如直接通过索引修改值），Object.defineProperty 无法完全拦截，需要额外的处理来实现响应式。

* **初始化数据时的限制：** Object.defineProperty 需要在初始化时递归遍历对象，并对每个属性进行 defineProperty 操作，这个过程可能会影响性能。

* **Proxy 的灵活性和拦截能力更强：** 相比之下，Proxy 提供了更全面和灵活的拦截能力，更符合 Vue 3 对于响应式系统的要求。

综上所述，Vue 3 使用 Proxy 替代 Object.defineProperty 主要是为了提供更强大、更灵活的响应式系统，带来更好的性能和开发体验。
:::

## Vue 和 React 的区别？

//TODO
